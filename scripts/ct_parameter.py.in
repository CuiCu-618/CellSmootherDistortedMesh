import argparse
import os
import subprocess
import sys
from argparse import RawTextHelpFormatter

HEADER_ = """
#ifndef CT_PARAMETER_CUH
#define CT_PARAMETER_CUH

#include "patch_base.cuh"

namespace CT
{
"""

FOOTER_ = """
} // namespace CT

#endif // CT_PARAMETER_CUH
"""

BUILD_DIR_ = os.path.abspath("@CMAKE_BINARY_DIR@")  # @...@ replaced by CMake
BUILD_INC_ = os.path.join(BUILD_DIR_, "include")
DEFAULT_OUTFILE_ = os.path.join(BUILD_INC_, "ct_parameter.h")


def parse_args():
    parser = argparse.ArgumentParser(
        description="""Create compile-time parameters.""",
        formatter_class=RawTextHelpFormatter,
    )
    parser.add_argument(
        "-O",
        "--output",
        help="output file of the compile-time parameters",
        type=argparse.FileType("w"),
        default=DEFAULT_OUTFILE_,
    )
    parser.add_argument(
        "-DIM",
        "--dimension",
        default=2,
        type=int,
        choices=[2, 3],
        help="spatial dimension of the domain",
    )
    parser.add_argument(
        "-DEG",
        "--fe-degree",
        default=4,
        type=int,
        choices=range(1, 11),
        help="spatial dimension of the domain",
    )
    parser.add_argument(
        "-NSMO",
        "--n_smooth_steps",
        default=1,
        type=int,
        choices=range(1, 11),
        help="spatial dimension of the domain",
    )
    parser.add_argument(
        "-PATCH_BLOCK",
        "--patch_per_block",
        default=1,
        type=int,
        choices=range(1, 65),
        help="number of shift elements",
    )
    parser.add_argument(
        "-REDUCE", "--reduce", default=1e-8, type=float, help="desired reduction factor"
    )
    parser.add_argument(
        "-MAXIT", "--max_steps", default=20, type=int, help="maximum number of steps"
    )
    parser.add_argument(
        "-MAXSIZE",
        "--max_sizes",
        default=500000,
        type=int,
        help="maximum number of dofs",
    )
    parser.add_argument(
        "-DLY",
        "--dof-layout",
        default="RT",
        type=str,
        choices=["Q", "DGQ", "RT"],
        help="dof layout of finite element method",
    )
    parser.add_argument(
        "-LOG", "--log-directory", default=BUILD_DIR_, help="directory of the log file"
    )
    parser.add_argument(
        "-LA",
        "--laplace_type",
        default="B",
        nargs="+",
        choices=["Basic", "Padding", "ConflictFree", "MatrixStruct"],
        help="variant of the Laplace operator kernel",
    )
    parser.add_argument(
        "-SMV",
        "--smooth_vmult",
        default="B",
        nargs="+",
        choices=["Basic", "ConflictFree", "MatrixStruct"],
        help="variant of the Schwarz smoother vmult operator",
    )
    parser.add_argument(
        "-SMI",
        "--smooth_inv",
        default="G",
        nargs="+",
        choices=["GLOBAL", "FUSED_L", "ConflictFree"],
        help="variant of the Schwarz smoother inverse operator",
    )
    parser.add_argument(
        "-SOL",
        "--local_solver",
        default="T",
        nargs="+",
        choices=["Direct", "SchurDirect", "SchurIter", "TensorProduct"],
        help="variant of the local solver operator",
    )
    parser.add_argument(
        "-G",
        "--granularity",
        default="none",
        choices=["none", "user_define", "multiple"],
        help="thread-block granularity scheme",
    )
    parser.add_argument(
        "-VNUM",
        "--vcycle_number",
        default="double",
        type=str,
        choices=["double", "float"],
        help="number type for the multigrid v-cycle",
    )
    parser.add_argument(
        "-SETS",
        "--test_sets",
        default="error_analysis",
        type=str,
        choices=["none", "kernel", "error_analysis", "vnum"],
        help="sets of experiments used for comparsion",
    )
    args = parser.parse_args()
    assert os.path.isdir(args.log_directory), "Invalid directory path: {}".format(
        args.log_directory
    )
    fpath = args.output.name
    assert os.path.isdir(os.path.dirname(fpath)), "Invalid output director: {}".format(
        os.path.dirname(fpath)
    )
    return args


def rawstr(string):
    return r'"' + string + r'"'


class Parameter:
    """Class containing the compile-time parameters."""

    def __init__(self):
        """generating default and parsed parameters"""
        options = parse_args()
        dim = options.dimension
        deg = options.fe_degree
        patch = options.patch_per_block
        nsmo = options.n_smooth_steps
        self.dimension = ("constexpr unsigned int", dim)
        self.fe_degree = ("constexpr unsigned int", deg)
        self.n_smooth_steps = ("constexpr unsigned int", nsmo)
        self.patch_per_block = ("constexpr unsigned int", patch)
        self.reduce = ("constexpr double", options.reduce)
        self.max_steps = ("constexpr unsigned int", options.max_steps)
        self.max_sizes = ("constexpr long long unsigned int", options.max_sizes)
        self.dof_layout = (
            "constexpr auto",
            "PSMF::DoFLayout::" + str(options.dof_layout),
        )
        self.vcycle_number = ("using", str(options.vcycle_number))
        self.log_dir = ("const std::string", rawstr(options.log_directory))
        self.sets = ("const std::string", rawstr(options.test_sets))
        self.laplace_prm(options.laplace_type)
        self.smooth_vmult_prm(options.smooth_vmult)
        self.smooth_inv_prm(options.smooth_inv)
        self.local_solver_prm(options.local_solver)
        self.granularity_prm(options.granularity)

    def laplace_prm(self, variant):
        """translate the variant into parameters"""
        kernel_str = "{{"
        count = 0
        for kernel in variant:
            if kernel.startswith("B"):
                kernel_str += r"PSMF::LaplaceVariant::Basic, "
                count += 1
            elif kernel.startswith("Padding"):
                kernel_str += r"PSMF::LaplaceVariant::BasicPadding, "
                count += 1
            elif kernel.endswith("Free"):
                kernel_str += r"PSMF::LaplaceVariant::ConflictFree, "
                count += 1
            elif kernel.startswith("Matrix"):
                kernel_str += r"PSMF::LaplaceVariant::MatrixStruct, "
                count += 1
        self.laplace_type = (
            "constexpr std::array<PSMF::LaplaceVariant, " + str(count) + ">",
            kernel_str + "}}",
        )

    def smooth_vmult_prm(self, variant):
        """translate the variant into parameters"""
        kernel_str = "{{"
        count = 0
        for kernel in variant:
            if kernel.startswith("B"):
                kernel_str += r"PSMF::LaplaceVariant::Basic, "
                count += 1
            elif kernel.startswith("Padding"):
                kernel_str += r"PSMF::LaplaceVariant::BasicPadding, "
                count += 1
            elif kernel.endswith("Free"):
                kernel_str += r"PSMF::LaplaceVariant::ConflictFree, "
                count += 1
            elif kernel.startswith("Matrix"):
                kernel_str += r"PSMF::LaplaceVariant::MatrixStruct, "
                count += 1
        self.smooth_vmult = (
            "constexpr std::array<PSMF::LaplaceVariant, " + str(count) + ">",
            kernel_str + "}}",
        )

    def smooth_inv_prm(self, variant):
        """translate the variant into parameters"""
        kernel_str = "{{"
        count = 0
        for kernel in variant:
            if kernel.startswith("G"):
                kernel_str += r"PSMF::SmootherVariant::GLOBAL, "
                count += 1
            if kernel.startswith("FUSED_L"):
                kernel_str += r"PSMF::SmootherVariant::FUSED_L, "
                count += 1
            elif kernel.endswith("Free"):
                kernel_str += r"PSMF::SmootherVariant::ConflictFree, "
                count += 1
        self.smooth_inv = (
            "constexpr std::array<PSMF::SmootherVariant, " + str(count) + ">",
            kernel_str + "}}",
        )

    def local_solver_prm(self, variant):
        """translate the variant into parameters"""
        kernel_str = "{{"
        count = 0
        for kernel in variant:
            if kernel.startswith("Direct"):
                kernel_str += r"PSMF::LocalSolverVariant::Direct, "
                count += 1
            elif kernel.endswith("SchurDirect"):
                kernel_str += r"PSMF::LocalSolverVariant::SchurDirect, "
                count += 1
            elif kernel.startswith("SchurIter"):
                kernel_str += r"PSMF::LocalSolverVariant::SchurIter, "
                count += 1
            elif kernel.startswith("T"):
                kernel_str += r"PSMF::LocalSolverVariant::SchurTensorProduct, "
                count += 1
        self.local_solver = (
            "constexpr std::array<PSMF::LocalSolverVariant, " + str(count) + ">",
            kernel_str + "}}",
        )

    def granularity_prm(self, variant):
        """translate the variant into parameters"""
        if variant.startswith("n"):
            self.granularity = ("constexpr auto", r"PSMF::GranularityScheme::none")
        elif variant.startswith("u"):
            self.granularity = (
                "constexpr auto",
                r"PSMF::GranularityScheme::user_define",
            )
        elif variant.startswith("m"):
            self.granularity = ("constexpr auto", r"PSMF::GranularityScheme::multiple")


def assignf(name_, type_, value_):
    """formatted string defining a C-style assignment"""
    name = name_.upper() + "_"
    return "{} {} = {};".format(type_, name, value_)


def main():
    options = parse_args()
    ostream = options.output

    def oprint(*objects, **kwargs):
        """prints the output to the given output stream"""
        print(*objects, file=ostream, **kwargs)

    #: modify the parameters
    prm = Parameter()

    #: write header to output
    oprint(HEADER_, sep="\n")

    #: write variables to output
    def unpack_var(variables):
        """unpacks the variables into its name, type and value"""
        for name_ in variables:
            type_, value_ = variables[name_]
            yield name_, type_, value_

    variables = vars(prm)
    for name, vtype, value in unpack_var(variables):
        oprint(assignf(name, vtype, value), sep="\n")

    #: write footer to output
    oprint(FOOTER_, sep="\n")

    #: close the output stream
    if options.output:
        ostream.close()


if __name__ == "__main__":
    main()
